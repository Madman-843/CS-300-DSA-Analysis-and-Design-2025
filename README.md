# CS-300-DSA-Analysis-and-Design-2025
The primary problem I addressed in this course was designing and implementing an advising assistance program that could efficiently load course data, display an alphanumeric list of courses, and provide detailed information about individual courses and their prerequisites. This required creating a menu-driven application and selecting an appropriate data structure to balance performance and usability.
My approach began with analyzing requirements and writing pseudocode to outline the menu flow and operations. Choosing the right data structure was critical because it directly impacts efficiency. I evaluated vectors, hash tables, and binary search trees (BSTs), ultimately selecting a self-balancing BST (AVL) to achieve fast lookups and in-order traversal for sorted output. Understanding data structures was essential because they determine how well a program scales and performs under real-world conditions.
I encountered challenges such as parsing inconsistent CSV input and implementing AVL rotations correctly. I overcame these by writing a robust parser that trims whitespace and normalizes course codes, and by carefully testing tree operations to maintain balance. These problem-solving steps reinforced the importance of planning and modular design.
Working on this project expanded my approach to software design by emphasizing scalability, adaptability, and clarity. I now prioritize separating concerns—such as parsing, storage, and user interaction—into distinct functions, which makes the code easier to maintain and extend. Additionally, I adopted best practices like descriptive naming, inline comments, and comprehensive error handling to improve readability and user experience.
Overall, this project evolved the way I write programs by instilling habits that ensure maintainability and adaptability. I now think beyond making code “work” and focus on designing solutions that are efficient, clear, and prepared for future enhancements.
